# Analysis of Algorithms

This repository contains a collection of practical programs implemented as part of the Analysis of Algorithms course (Semester 4) in the Computer Science Engineering (AI & ML) curriculum at the University of Mumbai. The programs are primarily written in Java, with some implemented in Python, to illustrate key algorithmic concepts.

## Table of Contents

- [Introduction](#introduction)
- [Programs Included](#programs-included)
- [Prerequisites](#prerequisites)
- [How to Run](#how-to-run)
- [Program Descriptions](#program-descriptions)
- [Contributing](#contributing)

## Introduction

This repository showcases various algorithms fundamental to computer science, including sorting, searching, graph algorithms, and more. The focus is on understanding and implementing these algorithms efficiently, as well as analyzing their time and space complexities.

## Programs Included

The repository contains the following programs:

1. **Sorting Algorithms**: Insertion Sort, Selection Sort.
2. **Array Operations**: Finding Minimum and Maximum Element in an Array.
3. **Quicksort**: Implementation of the Quick Sort algorithm.
4. **Binary Search**: Efficient searching in a sorted array.
5. **Shortest Path Algorithms**: Algorithms to find the shortest path in graphs.
6. **Greedy Algorithms**: Fractional Knapsack Problem.
7. **Graph Algorithms**: Bellman-Ford Algorithm for shortest paths.
8. **Optimization Problems**: Travelling Salesperson Problem (TSP).
9. **Backtracking Algorithms**: N-Queen Problem.
10. **String Matching Algorithm**

## Prerequisites

To run these programs, you'll need:

- **Java Development Kit (JDK)** for Java programs.
- **Python** (optional) for programs implemented in Python.
- Basic understanding of algorithms and data structures.
- An Integrated Development Environment (IDE) like IntelliJ IDEA, Eclipse, NetBeans, or any Python IDE for Python programs.

## How to Run

### Running Java Programs

1. **Clone the Repository:**
   ```sh
   git clone https://github.com/DevadattaP/Analysis-of-Algorithms.git
   cd Analysis-of-Algorithms
    ```
2. **Open the Project in an IDE:**

    - Open your preferred Java IDE.
    - Import the cloned repository as a Java project.
  
3. **Compile and Run:**

    - Navigate to the program you wish to run.
    - Compile the program using the IDE's build functionality.
    - Run the program within the IDE.
  
## Program Descriptions

### 1. Sorting Algorithms
   - **Insertion Sort**: A simple sorting algorithm that builds the final sorted array one item at a time.
   - **Selection Sort**: An in-place comparison sort that divides the input list into two parts: the sorted and the unsorted.

### 2. Array Operations
   - **Finding Minimum and Maximum Element**: A program to find the smallest and largest elements in an array.

### 3. Quicksort
   - **Quicksort**: A fast, recursive, divide-and-conquer algorithm that sorts elements by partitioning arrays.

### 4. Binary Search
   - **Binary Search**: An efficient algorithm for finding an item from a sorted list of items, operating in O(log n) time.

### 5. Shortest Path Algorithms
   - **Finding Shortest Path**: Implements algorithms like Dijkstra's or others to find the shortest path in a graph.

### 6. Greedy Algorithms
   - **Fractional Knapsack Problem**: Solves the knapsack problem using a greedy algorithm approach.

### 7. Graph Algorithms
   - **Bellman-Ford Algorithm**: Finds the shortest path in a weighted graph, capable of handling negative weights.

### 8. Optimization Problems
   - **Travelling Salesperson Problem (TSP)**: A classic optimization problem aiming to find the shortest possible route that visits each city and returns to the origin city.

### 9. Backtracking Algorithms
   - **N-Queen Problem**: Solves the N-Queen puzzle using backtracking.

### 10. String Algorithms
   - **String Matching Algorithms**: Implements algorithms to find occurrences of a substring within a string, like the Knuth-Morris-Pratt (KMP) algorithm.

> [!NOTE] 
> The specific names of the programs may vary, and some algorithms might have been explored in both Java and Python.

## Contributing
Contributions are welcome! If you have improvements or additional algorithms to add, feel free to fork the repository, make your changes, and submit a pull request.